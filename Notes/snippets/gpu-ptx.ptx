### square算子的PTX

# 关键信息：每次8个register计算乘法


// 文件头信息

//
// Generated by LLVM NVPTX Back-End
//

.version 8.1
.target sm_86
.address_size 64


// 内核函数定义

.visible.entry square_kernel_0d1d234(
   .param.u64 square_kernel_0d1d234_param_0,
   .param.u64 square_kernel_0d1d234_param_1,
   .param.u32 square_kernel_0d1d234_param_2,
   .param.u32 square_kernel_0d1d234_param_3,
   .param.u32 square_kernel_0d1d234_param_4
)
.maxntid 128, 1, 1      // 最大线程数：.maxntid 128, 1, 1 表示每个线程块在 x、y、z 维度上的最大线程数分别为 128、1、1。

// 寄存器声明

.reg.pred  %p<25>;    // .pred 类型的寄存器（布尔类型），最多 25 个，用于条件判断。
.reg.b32   %r<40>;
.reg.f32   %f<17>;
.reg.b64   %rd<24>;


// 内核函数主体

// 参数加载
ld.param.u64  %rd17, [square_kernel_0d1d234_param_0];
ld.param.u64  %rd18, [square_kernel_0d1d234_param_1];

// 线程索引计算
mov.u32  %r25, %tid.x;
and.b32  %r26, %r25, 127;

// 地址计算
mul.wide.s32  %rd19, %r38, 4;
add.s64  %rd20, %rd18, %rd19;

// 内存加载
@%p1 ld.global.b32 { %r1 }, [ %rd1 + 0 ];
@!%p1 mov.u32 %r1, %r2; 

// 根据条件寄存器 %p1 的值决定是否从全局内存加载 32 位数据到寄存器 %r1 中。
// 如果 %p1 为假，则将寄存器 %r2 的值赋给 %r1。

// 数值计算
mul.f32  %f9, %f1, %f1;

// 内存存储
mov.b32  %r17, %f9;
@%p1 st.global.b32 [ %rd9 + 0 ], { %r17 };

// 条件返回
ret;

// 调试信息
.debug_abbrev、.debug_info、.debug_pubnames、.debug_pubtypes 和 .debug_loc