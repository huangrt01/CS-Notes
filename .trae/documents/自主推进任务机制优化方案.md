
---
id: self-driven-optimization-20260218
title: "自主推进任务机制优化方案"
priority: high
status: in_progress
created_at: 2026-02-18T03:00:00
updated_at: 2026-02-18T03:00:00
tags: ["自主推进", "heartbeat", "优化方案", "OpenClaw"]
---

# 自主推进任务机制优化方案

## 问题背景

### 当前问题

根据用户的语音反馈，当前机制存在以下问题：

1. **过度依赖 heartbeat**：目前的自主推进比较依赖 heartbeat 来触发
2. **心跳间隔两难**：
   - 心跳间隔太长 → 错过需要及时推进的任务
   - 心跳间隔太短 → 不必要的检查和资源浪费
3. **用户期望**：
   - "起床后，每个 todo 都到了不得不依赖他做些什么或者做决策的阶段"
   - "在用户两次干预之间主动推进任务，不等待 heartbeat"

---

## 优化思路（两个维度）

### 维度一：结合当前 heartbeat 机制本身怎么优化

### 维度二：跳出这个局限性，去思考怎么去优化

---

## 维度一：Heartbeat 机制本身的优化

### 1.1 动态心跳间隔

**问题**：固定的 30 分钟间隔不够灵活

**方案**：根据任务队列状态动态调整心跳间隔

| 场景 | 心跳间隔 |
|------|----------|
| 有待执行的 high 优先级任务 | 5 分钟 |
| 有待执行的 medium 优先级任务 | 15 分钟 |
| 只有 low 优先级任务 | 30 分钟 |
| 没有待执行任务 | 60 分钟 |

**实现方式**：
- 每次 heartbeat 时检查任务队列状态
- 根据任务优先级动态计算下次心跳间隔
- 更新 cron 任务的 schedule

---

### 1.2 分层心跳检查

**问题**：每次 heartbeat 都检查所有任务，效率低

**方案**：将检查任务分层，不同频率检查不同内容

| 层级 | 检查内容 | 频率 |
|------|---------|------|
| L1 | High 优先级任务 | 5 分钟 |
| L2 | Medium 优先级任务 | 15 分钟 |
| L3 | Low 优先级任务 + Session 状态 | 30 分钟 |
| L4 | 完整状态检查 + 归档整理 | 6 小时 |

**实现方式**：
- 创建多个 cron 任务，不同频率触发
- 每个 cron 任务只检查对应层级的内容
- 避免重复检查

---

### 1.3 事件驱动 + 心跳兜底

**问题**：完全依赖心跳，响应不够及时

**方案**：事件驱动为主，心跳作为兜底

| 触发方式 | 场景 | 响应时间 |
|---------|------|---------|
| 事件驱动 | 用户添加新任务、标记任务完成 | 立即 |
| 心跳兜底 | 定期检查，确保没有遗漏 | 30 分钟 |

**实现方式**：
- 监听 todo 管理系统的文件变更
- 当检测到文件变更时，立即触发一次检查
- 心跳继续作为兜底机制

---

## 维度二：跳出 heartbeat 局限性的优化

### 2.1 用户干预之间的主动推进

**核心思路**：不等待 heartbeat，在用户两次干预之间主动推进任务

**实现机制**：

1. **记录用户干预时间**：
   - 每次用户发送消息时，记录当前时间
   - 更新 `last_user_intervention_time`

2. **任务计数器**：
   - 记录两次用户干预之间已执行的任务数量
   - 超过 `MAX_TASKS_BETWEEN_INTERVENTIONS`（默认 4）时暂停
   - 用户干预后重置计数器

3. **推进时机**：
   - **立即推进**：用户发送完消息后，立即开始推进任务
   - **连续推进**：完成一个任务后，立即开始下一个任务
   - **暂停条件**：
     - 达到任务数量上限
     - 遇到需要用户确认的任务
     - 用户发送新消息

**状态管理**：
```json
{
  "last_user_intervention_time": "2026-02-18T03:00:00",
  "tasks_executed_since_last_intervention": 2,
  "is_pushing": false,
  "current_task": null,
  "task_queue": []
}
```

---

### 2.2 智能任务调度器

**核心思路**：不只是按优先级排序，还要智能调度

**调度策略**：

1. **依赖关系分析**：
   - 分析任务之间的依赖关系
   - 先执行没有依赖的任务
   - 避免阻塞后续任务

2. **任务分组**：
   - 将相似的任务分组执行
   - 例如：多个笔记整理任务一起执行
   - 减少上下文切换开销

3. **预估执行时间**：
   - 根据历史数据预估每个任务的执行时间
   - 优先执行短时间能完成的任务
   - 长时间任务放在用户休息时执行

4. **用户习惯学习**：
   - 学习用户通常什么时间活跃
   - 在用户活跃前提前完成准备工作
   - 在用户休息时执行长时间任务

---

### 2.3 闭环自我迭代

**核心思路**：执行 → 发现新任务 → 添加新任务 → 继续执行

**实现机制**：

1. **任务执行中的发现**：
   - 在执行任务过程中，主动发现新的 todo
   - 这些新 todo 必须对齐最终目标
   - 自动添加到 todo manager 中

2. **新任务评估**：
   - 评估新任务的优先级
   - 评估新任务是否需要用户确认
   - 如果不需要确认，立即加入执行队列

3. **闭环反馈**：
   - 完成一个任务后，立即检查是否有新发现的任务
   - 如果有，继续执行
   - 形成闭环：执行 → 发现 → 添加 → 继续执行

---

### 2.4 子 Agent 池 + 任务分发

**核心思路**：使用子 Agent 并行执行任务，提高效率

**架构设计**：

```
                    ┌─────────────┐
                    │  主 Agent   │
                    │ (调度器)    │
                    └──────┬──────┘
                           │
            ┌──────────────┼──────────────┐
            │              │              │
    ┌───────▼──────┐ ┌─────▼──────┐ ┌──▼─────────┐
    │ 子 Agent 1  │ │ 子 Agent 2 │ │ 子 Agent 3│
    │ (笔记整理)   │ │ (Git 操作)  │ │ (监控)    │
    └──────────────┘ └────────────┘ └────────────┘
```

**实现机制**：

1. **子 Agent 池**：
   - 预创建多个子 Agent，不同类型处理不同任务
   - 最多并发 `MAX_CONCURRENT_SUBAGENTS`（默认 5）个

2. **任务分发**：
   - 主 Agent 负责任务分发
   - 根据任务类型选择合适的子 Agent
   - 监控子 Agent 的执行状态

3. **结果聚合**：
   - 子 Agent 执行完成后，结果返回给主 Agent
   - 主 Agent 聚合所有结果
   - 更新 todo manager 和用户通知

---

### 2.5 主动任务推荐

**核心思路**：不只是执行已有任务，还要主动推荐应该做什么

**推荐机制**：

1. **上下文分析**：
   - 分析用户最近关注的主题
   - 分析最近完成的任务
   - 识别用户的当前关注点

2. **任务推荐**：
   - 推荐与当前关注点相关的任务
   - 推荐能推进长期目标的任务
   - 推荐能填补知识空白的任务

3. **推荐呈现方式**：
   - 不是直接执行，而是推荐给用户
   - 用户确认后再执行
   - 推荐时说明理由

---

## 综合优化方案

### 阶段一：快速实现（1-2 天）

1. ✅ **用户干预之间的主动推进**
   - 记录用户干预时间
   - 任务计数器
   - 立即推进机制

2. ✅ **分层心跳检查**
   - L1：High 优先级任务（5 分钟）
   - L2：Medium 优先级任务（15 分钟）
   - L3：Low 优先级 + Session 状态（30 分钟）

3. ✅ **闭环自我迭代**
   - 执行任务时发现新 todo
   - 自动添加到 todo manager
   - 继续执行

### 阶段二：中期优化（3-5 天）

1. **动态心跳间隔**
   - 根据任务队列状态调整
   - 高优先级任务时缩短间隔

2. **智能任务调度器**
   - 依赖关系分析
   - 任务分组执行
   - 预估执行时间

3. **子 Agent 池**
   - 创建子 Agent
   - 任务分发机制
   - 结果聚合

### 阶段三：长期优化（1-2 周）

1. **事件驱动 + 心跳兜底**
   - 文件变更监听
   - 立即触发检查
   - 心跳作为兜底

2. **主动任务推荐**
   - 上下文分析
   - 任务推荐算法
   - 推荐理由生成

3. **用户习惯学习**
   - 活跃时间学习
   - 任务偏好学习
   - 个性化调度

---

## 技术实现细节

### 状态文件结构

```json
{
  "last_user_intervention_time": "2026-02-18T03:00:00",
  "tasks_executed_since_last_intervention": 2,
  "max_tasks_between_interventions": 4,
  "is_pushing": false,
  "current_task": null,
  "task_queue": [],
  "subagents": {
    "active": [],
    "max_concurrent": 5
  },
  "heartbeat": {
    "current_interval": 30,
    "last_check": "2026-02-18T03:00:00",
    "check_history": []
  },
  "discoveries": [
    {
      "task": "任务名称",
      "discovery": "发现内容",
      "timestamp": "2026-02-18T03:00:00"
    }
  ]
}
```

---

## 总结

### 核心优化点

1. **从"等待心跳"到"主动推进"**：
   - 用户干预后立即开始推进
   - 不等待心跳触发

2. **从"单一机制"到"多层机制"**：
   - 事件驱动 + 心跳兜底
   - 分层检查，不同频率

3. **从"被动执行"到"主动发现"**：
   - 执行任务时发现新 todo
   - 闭环自我迭代
   - 主动任务推荐

### 最终目标

> **"起床后，每个 todo 都到了不得不依赖他做些什么或者做决策的阶段"**

通过以上优化，AI 能够：
- ✅ 在用户两次干预之间主动推进任务
- ✅ 智能调度，高效执行
- ✅ 发现新任务，闭环迭代
- ✅ 最终让用户只需要做决策

---

*最后更新：2026-02-18*

